package com.vortex.framework.services.role;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.server.ResponseStatusException;

import com.vortex.framework.common.FirebaseUtils;
import com.vortex.framework.converters.role.RoleConverter;
import com.vortex.framework.entities.role.Role;
import com.vortex.framework.entities.role.RoleRepository;
import com.vortex.framework.objects.role.RoleVO;

@Controller // This means that this class is a Controller
@CrossOrigin
//Allow all (origins = { "http://localhost:4200", "https://dev-shreksworld.duckdns.org", "https://uat-shreksworld.duckdns.org", "https://shreksworld.duckdns.org" })
@RequestMapping(path = "/rolesvc/role") // This means URL's start with /rolesvc (after Application path)
public class RolesController {
	@Autowired // This means to get the bean called userRepository
	// Which is auto-generated by Spring, we will use it to handle the data
	private RoleRepository roleRepository;

	@Value("${vortex.framework.should.skipauthcheck}")
	private String shouldSkipAuths;
	
	private boolean shouldSkipAuthChecks() {
		return "Y".equalsIgnoreCase(shouldSkipAuths);
	}

	/**
	 * @param idToken
	 * @param tRole
	 * @return
	 */
	@PostMapping(path = "/add") // Map ONLY POST Requests
	public @ResponseBody RoleVO add(@RequestHeader("Authorization") String idToken,
			@RequestBody RoleVO tRole) {

		String uid = FirebaseUtils.getDecodedFireBaseToken(idToken);
		if (uid != null || shouldSkipAuthChecks()) {
			Role newRole =RoleConverter.convertVOToEntity(tRole);
			roleRepository.save(newRole);
			return RoleConverter.convertEntityToVO(newRole);
		}
		throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Actor Not Found");
	}

	/**
	 * @param idToken
	 * @param tRole
	 * @return
	 */
	@PostMapping("/delete")
	@ResponseBody RoleVO markAsDeleted(@RequestHeader("Authorization") String idToken, @RequestBody RoleVO tRole) {
		String uid = FirebaseUtils.getDecodedFireBaseToken(idToken);
		if (uid != null || shouldSkipAuthChecks()) {
			Optional<Role> role = roleRepository.findById(tRole.getId());
			if (role != null) {
				Role roleEntity = role.get();
				roleEntity.setActive("N");
				roleRepository.save(roleEntity);
				return RoleConverter.convertEntityToVO(roleEntity);
			}
		}
		throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Actor Not Found");
	}

	@PostMapping("/read")
	@ResponseBody RoleVO readOne(@RequestHeader("Authorization") String idToken, @RequestBody RoleVO tRole) {
		String uid = FirebaseUtils.getDecodedFireBaseToken(idToken);
		if (uid != null || shouldSkipAuthChecks()) {
			Optional<Role> role = roleRepository.findById(tRole.getId());
			if (role != null) {
				Role roleEntity = role.get();
				return RoleConverter.convertEntityToVO(roleEntity);
			}
		}
		throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Actor Not Found");
	}
	
	/**
	 * @param idToken
	 * @return
	 */
	@GetMapping(path = "/all")
	public @ResponseBody Iterable<RoleVO> getActive(@RequestHeader("Authorization") String idToken) {

		List<RoleVO> allRoles = new ArrayList<>();

		String uid = FirebaseUtils.getDecodedFireBaseToken(idToken);
		if (uid != null || shouldSkipAuthChecks()) {
			// This returns a JSON or XML with the items
			List<Role> tRoles = roleRepository.findActiveRoles();
			for (Role eachRole : tRoles) {
				allRoles.add(RoleConverter.convertEntityToVO(eachRole));
			}
			return allRoles;
		}
		throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Actor Not Found");
	}
}